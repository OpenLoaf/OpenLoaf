import { app, BrowserWindow, ipcMain, screen, WebContentsView } from 'electron';
import { spawn, type ChildProcess } from 'node:child_process';
import fs from 'node:fs';
import path from 'node:path';
import http from 'node:http';
import net from 'node:net';

// Logging setup immediately to catch early errors
const logPath = path.join(app.getPath('userData'), 'startup.log');

function log(message: string) {
  try {
    const timestamp = new Date().toISOString();
    fs.appendFileSync(logPath, `[${timestamp}] ${message}\n`);
  } catch (e) {
    // console.error('Failed to write log', e);
  }
}

// Clear log on startup
try {
  fs.writeFileSync(logPath, `--- Startup ---\n`);
} catch {}

process.on('uncaughtException', (error) => {
  log(`UNCAUGHT EXCEPTION: ${error.stack || error.message}`);
  // Keep app running if possible or let it crash after logging
});

process.on('unhandledRejection', (reason) => {
  log(`UNHANDLED REJECTION: ${reason}`);
});

log(`App starting. UserData: ${app.getPath('userData')}`);
log(`Executable: ${process.execPath}`);
log(`Resources Path: ${process.resourcesPath}`);

// Enable Chrome DevTools Protocol (CDP)
// Use 0 (auto) to avoid "port already in use" on startup.
app.commandLine.appendSwitch(
  'remote-debugging-port',
  process.env.TEATIME_REMOTE_DEBUGGING_PORT ?? '0'
);

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const LOADING_WINDOW_WEBPACK_ENTRY: string;
declare const LOADING_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

const DEFAULT_SERVER_URL = 'http://127.0.0.1:3000';
const DEFAULT_WEB_URL = 'http://127.0.0.1:3001';

const MIME_TYPES: Record<string, string> = {
  '.html': 'text/html',
  '.js': 'text/javascript',
  '.css': 'text/css',
  '.json': 'application/json',
  '.png': 'image/png',
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.gif': 'image/gif',
  '.svg': 'image/svg+xml',
  '.ico': 'image/x-icon',
  '.woff': 'font/woff',
  '.woff2': 'font/woff2',
  '.ttf': 'font/ttf',
  '.txt': 'text/plain',
  '.webmanifest': 'application/manifest+json',
};

const sleep = (ms: number) =>
  new Promise<void>((resolve) => setTimeout(resolve, ms));

const canFetch = typeof fetch === 'function';

async function isPortFree(host: string, port: number): Promise<boolean> {
  return new Promise((resolve) => {
    const server = net.createServer();
    server.once('error', () => resolve(false));
    server.once('listening', () => {
      server.close(() => resolve(true));
    });
    server.listen(port, host);
  });
}

async function getFreePort(host: string): Promise<number> {
  return new Promise((resolve, reject) => {
    const server = net.createServer();
    server.unref();
    server.once('error', reject);
    server.listen(0, host, () => {
      const addr = server.address();
      if (!addr || typeof addr === 'string') {
        server.close(() => reject(new Error('Failed to allocate a free port')));
        return;
      }
      const port = addr.port;
      server.close((err) => {
        if (err) reject(err);
        else resolve(port);
      });
    });
  });
}

async function isUrlOk(url: string): Promise<boolean> {
  if (!canFetch) return false;
  try {
    const res = await fetch(url, { method: 'GET' });
    return res.ok;
  } catch {
    return false;
  }
}

async function waitForUrlOk(
  url: string,
  { timeoutMs, intervalMs }: { timeoutMs: number; intervalMs: number }
): Promise<boolean> {
  const start = Date.now();
  for (;;) {
    if (await isUrlOk(url)) return true;
    if (Date.now() - start > timeoutMs) return false;
    await sleep(intervalMs);
  }
}

function findRepoRoot(startDir: string): string | null {
  let current = startDir;
  for (let i = 0; i < 12; i++) {
    if (
      fs.existsSync(path.join(current, 'pnpm-workspace.yaml')) &&
      fs.existsSync(path.join(current, 'turbo.json'))
    ) {
      return current;
    }
    const parent = path.dirname(current);
    if (parent === current) break;
    current = parent;
  }
  return null;
}

function commandName(base: string): string {
  return process.platform === 'win32' ? `${base}.cmd` : base;
}

function spawnLogged(
  label: string,
  command: string,
  args: string[],
  opts: { cwd: string; env: NodeJS.ProcessEnv }
): ChildProcess {
  const child = spawn(command, args, {
    cwd: opts.cwd,
    env: opts.env,
    stdio: ['ignore', 'pipe', 'pipe'],
  });

  child.stdout?.on('data', (d) => process.stdout.write(`[${label}] ${d}`));
  child.stderr?.on('data', (d) => process.stderr.write(`[${label}] ${d}`));
  child.on('exit', (code, signal) => {
    process.stdout.write(
      `[${label}] exited (${code ?? 'null'}, ${signal ?? 'null'})\n`
    );
  });

  return child;
}

let managedServer: ChildProcess | null = null;
let managedWeb: ChildProcess | null = null;
let productionWebServer: http.Server | null = null;

async function ensureDevServices(
  initialServerUrl: string,
  initialWebUrl: string
): Promise<{ serverUrl: string; webUrl: string }> {
  if (app.isPackaged)
    return { serverUrl: initialServerUrl, webUrl: initialWebUrl };

  const repoRoot = findRepoRoot(process.cwd());
  if (!repoRoot) return { serverUrl: initialServerUrl, webUrl: initialWebUrl };

  let serverUrl = initialServerUrl;
  let webUrl = initialWebUrl;

  let serverOk = await isUrlOk(`${serverUrl}/`);
  let webOk = await isUrlOk(`${webUrl}/`);
  if (!serverOk || !webOk) {
    await sleep(1500);
    serverOk = serverOk || (await isUrlOk(`${serverUrl}/`));
    webOk = webOk || (await isUrlOk(`${webUrl}/`));
  }
  if (serverOk && webOk) return { serverUrl, webUrl };

  const pnpm = commandName('pnpm');
  const envBase = { ...process.env };

  let serverHost = new URL(serverUrl).hostname || '127.0.0.1';
  let serverPort = Number(new URL(serverUrl).port || 3000);
  if (!serverOk && !(await isPortFree(serverHost, serverPort))) {
    serverPort = await getFreePort(serverHost);
    serverUrl = `http://${serverHost}:${serverPort}`;
    log(`Server port in use; switched to ${serverUrl}`);
  }

  let webHost = new URL(webUrl).hostname || '127.0.0.1';
  let webPort = Number(new URL(webUrl).port || 3001);
  if (!webOk && !(await isPortFree(webHost, webPort))) {
    webPort = await getFreePort(webHost);
    webUrl = `http://${webHost}:${webPort}`;
    log(`Web port in use; switched to ${webUrl}`);
  }

  if (!serverOk) {
    managedServer = spawnLogged('server', pnpm, ['--filter', 'server', 'dev'], {
      cwd: repoRoot,
      env: {
        ...envBase,
        PORT: String(serverPort),
        HOST: serverHost,
        NODE_ENV: 'development',
        CORS_ORIGIN: `${webUrl},${envBase.CORS_ORIGIN ?? ''}`,
      },
    });

    await waitForUrlOk(`${serverUrl}/`, { timeoutMs: 30_000, intervalMs: 300 });
  }

  if (!webOk) {
    managedWeb = spawnLogged(
      'web',
      pnpm,
      [
        '--filter',
        'web',
        'exec',
        'next',
        'dev',
        `--port=${webPort}`,
        `--hostname=${webHost}`,
      ],
      {
        cwd: repoRoot,
        env: {
          ...envBase,
          NODE_ENV: 'development',
          NEXT_PUBLIC_SERVER_URL: serverUrl,
          NEXT_PUBLIC_ELECTRON: '1',
        },
      }
    );

    await waitForUrlOk(`${webUrl}/`, { timeoutMs: 60_000, intervalMs: 300 });
  }

  return { serverUrl, webUrl };
}

function serveStatic(req: http.IncomingMessage, res: http.ServerResponse, root: string) {
  try {
    let url = req.url || '/';
    // Remove query string
    url = url.split('?')[0];
    
    // Safety check
    if (url.includes('..')) {
      res.statusCode = 403;
      res.end('Forbidden');
      return;
    }

    let filePath = path.join(root, url);
    
    // Handle directory -> index.html
    if (fs.existsSync(filePath) && fs.statSync(filePath).isDirectory()) {
      filePath = path.join(filePath, 'index.html');
    }

    // Fallback logic for SPA / Next.js export
    if (!fs.existsSync(filePath)) {
      // 1. Try appending .html (e.g. /about -> /about.html)
      if (fs.existsSync(filePath + '.html')) {
        filePath += '.html';
      } 
      // 2. Try 404.html
      else if (fs.existsSync(path.join(root, '404.html'))) {
        filePath = path.join(root, '404.html');
      } 
      // 3. 404
      else {
        res.statusCode = 404;
        res.end('Not Found');
        return;
      }
    }

    const ext = path.extname(filePath).toLowerCase();
    const mimeType = MIME_TYPES[ext] || 'application/octet-stream';

    res.setHeader('Content-Type', mimeType);
    
    const stream = fs.createReadStream(filePath);
    stream.pipe(res);
    stream.on('error', (err) => {
        log(`Stream error serving ${filePath}: ${err.message}`);
        if (!res.headersSent) {
            res.statusCode = 500;
            res.end('Internal Server Error');
        }
    });

  } catch (err) {
    log(`Error in serveStatic: ${err instanceof Error ? err.message : String(err)}`);
    if (!res.headersSent) {
        res.statusCode = 500;
        res.end('Internal Server Error');
    }
  }
}

async function startProductionServices() {
  if (!app.isPackaged) return;

  log('Starting production services...');

  const resourcesPath = process.resourcesPath;
  const userDataPath = app.getPath('userData');
  const dbPath = path.join(userDataPath, 'teatime.db');
  
  // 1. Start Server
  // Note: server.mjs is copied to Resources/server.mjs
  const serverPath = path.join(resourcesPath, 'server.mjs');
  log(`Looking for server at: ${serverPath}`);
  
  if (fs.existsSync(serverPath)) {
      try {
          managedServer = spawn(process.execPath, [serverPath], {
            env: {
                ...process.env,
                ELECTRON_RUN_AS_NODE: '1',
                PORT: '3000',
                DATABASE_URL: `file:${dbPath}`,
                NODE_ENV: 'production'
            },
            stdio: ['ignore', 'pipe', 'pipe']
          });

          managedServer.stdout?.on('data', (d) => log(`[Server Output] ${d}`));
          managedServer.stderr?.on('data', (d) => log(`[Server Error] ${d}`));
          managedServer.on('error', (err) => log(`[Server Spawn Error] ${err.message}`));
          managedServer.on('exit', (code, signal) => log(`[Server Exited] code=${code} signal=${signal}`));

          log('Server process spawned');
      } catch (err) {
          log(`Failed to spawn server: ${err instanceof Error ? err.message : String(err)}`);
      }
  } else {
      log(`[Error] Server binary not found at ${serverPath}`);
  }

  // 2. Start Web Server
  // Note: web/out is copied to Resources/out
  const webRoot = path.join(resourcesPath, 'out');
  log(`Looking for web root at: ${webRoot}`);
  
  if (fs.existsSync(webRoot)) {
      try {
          productionWebServer = http.createServer((req, res) => {
              serveStatic(req, res, webRoot);
          });
          
          await new Promise<void>((resolve, reject) => {
              productionWebServer?.listen(3001, () => {
                 log('Web server running at http://localhost:3001');
                 resolve();
              });
              productionWebServer?.on('error', reject);
          });
      } catch (err) {
          log(`Failed to start web server: ${err instanceof Error ? err.message : String(err)}`);
      }
  } else {
       log(`[Error] Web root not found at ${webRoot}`);
  }
}


function stopManaged(child: ChildProcess | null) {
  if (!child) return;
  if (child.killed) return;
  try {
    child.kill('SIGTERM');
  } catch {
    // ignore
  }
}

function getDefaultWindowSize(): { width: number; height: number } {
  const MIN_WIDTH = 800;
  const MIN_HEIGHT = 640;
  const MAX_WIDTH = 2000;
  const ASPECT_W = 16;
  const ASPECT_H = 10;

  const display = screen.getDisplayNearestPoint(screen.getCursorScreenPoint());
  const workAreaWidth = display.workAreaSize.width;

  let width = Math.round(workAreaWidth * 0.8);
  width = Math.min(width, MAX_WIDTH);
  width = Math.max(width, MIN_WIDTH);

  let height = Math.round((width * ASPECT_H) / ASPECT_W);
  if (height < MIN_HEIGHT) {
    height = MIN_HEIGHT;
    width = Math.round((height * ASPECT_W) / ASPECT_H);
    width = Math.min(width, MAX_WIDTH);
    width = Math.max(width, MIN_WIDTH);
  }

  return { width, height };
}

function normalizeExternalUrl(raw: string): string {
  const value = raw.trim();
  if (!value) {
    throw new Error('URL is empty');
  }
  // Allow explicit schemes.
  if (/^[a-zA-Z][a-zA-Z0-9+.-]*:\/\//.test(value)) return value;
  // Support localhost:xxxx style inputs.
  if (/^localhost(:\d+)?(\/|$)/.test(value)) return `http://${value}`;
  return `https://${value}`;
}

function createBrowserWindowForUrl(url: string): BrowserWindow {
  const normalized = normalizeExternalUrl(url);
  const parsed = new URL(normalized);
  if (parsed.protocol !== 'http:' && parsed.protocol !== 'https:') {
    throw new Error(`Unsupported protocol: ${parsed.protocol}`);
  }

  const parent = BrowserWindow.getAllWindows()[0];
  const win = new BrowserWindow({
    width: 1200,
    height: 800,
    parent: parent ?? undefined,
    webPreferences: {
      contextIsolation: true,
      nodeIntegration: false,
      sandbox: true,
    },
  });

  void win.loadURL(parsed.toString());
  return win;
}

type ViewBounds = { x: number; y: number; width: number; height: number };
type UpsertWebContentsViewArgs = {
  key: string;
  url: string;
  bounds: ViewBounds;
  visible?: boolean;
};

const viewMapsByWindowId = new Map<number, Map<string, WebContentsView>>();

function clampViewBounds(bounds: ViewBounds): ViewBounds {
  const safe = {
    x: Number.isFinite(bounds.x) ? Math.round(bounds.x) : 0,
    y: Number.isFinite(bounds.y) ? Math.round(bounds.y) : 0,
    width: Number.isFinite(bounds.width) ? Math.round(bounds.width) : 0,
    height: Number.isFinite(bounds.height) ? Math.round(bounds.height) : 0,
  };
  safe.width = Math.max(0, safe.width);
  safe.height = Math.max(0, safe.height);
  return safe;
}

function getOrCreateViewMapForWindow(win: BrowserWindow): Map<string, WebContentsView> {
  const existing = viewMapsByWindowId.get(win.id);
  if (existing) return existing;

  const map = new Map<string, WebContentsView>();
  viewMapsByWindowId.set(win.id, map);

  win.on('closed', () => {
    for (const view of map.values()) {
      try {
        win.contentView.removeChildView(view);
      } catch {}
      try {
        view.webContents.destroy();
      } catch {}
    }
    viewMapsByWindowId.delete(win.id);
  });

  return map;
}

function upsertWebContentsView(win: BrowserWindow, args: UpsertWebContentsViewArgs) {
  const key = String(args.key ?? '').trim();
  if (!key) throw new Error('Missing view key');

  const url = normalizeExternalUrl(args.url ?? '');
  const parsed = new URL(url);
  if (parsed.protocol !== 'http:' && parsed.protocol !== 'https:') {
    throw new Error(`Unsupported protocol: ${parsed.protocol}`);
  }

  const bounds = clampViewBounds(args.bounds);
  const map = getOrCreateViewMapForWindow(win);
  let view = map.get(key);

  if (!view) {
    view = new WebContentsView({
      webPreferences: {
        contextIsolation: true,
        nodeIntegration: false,
        sandbox: true,
      },
    });
    map.set(key, view);
    win.contentView.addChildView(view);
  }

  try {
    // If supported by the underlying View implementation.
    // @ts-expect-error Electron runtime provides setVisible on View.
    view.setVisible(args.visible !== false);
  } catch {}

  view.setBounds(bounds);

  const currentUrl = view.webContents.getURL();
  if (currentUrl !== parsed.toString()) {
    void view.webContents.loadURL(parsed.toString());
  }
}

function destroyWebContentsView(win: BrowserWindow, key: string) {
  const map = viewMapsByWindowId.get(win.id);
  const view = map?.get(key);
  if (!map || !view) return;

  map.delete(key);
  try {
    win.contentView.removeChildView(view);
  } catch {}
  try {
    view.webContents.destroy();
  } catch {}
}

let ipcHandlersRegistered = false;
function registerIpcHandlers() {
  if (ipcHandlersRegistered) return;
  ipcHandlersRegistered = true;

  ipcMain.handle(
    'teatime:open-browser-window',
    async (_event, args: { url: string }) => {
      const win = createBrowserWindowForUrl(args?.url ?? '');
      return { id: win.id };
    }
  );

  ipcMain.handle(
    'teatime:webcontents-view:upsert',
    async (event, args: UpsertWebContentsViewArgs) => {
      const win = BrowserWindow.fromWebContents(event.sender);
      if (!win) throw new Error('No BrowserWindow for sender');
      upsertWebContentsView(win, args);
      return { ok: true };
    }
  );

  ipcMain.handle(
    'teatime:webcontents-view:destroy',
    async (event, args: { key: string }) => {
      const win = BrowserWindow.fromWebContents(event.sender);
      if (!win) throw new Error('No BrowserWindow for sender');
      destroyWebContentsView(win, String(args?.key ?? ''));
      return { ok: true };
    }
  );
}

registerIpcHandlers();

const createWindow = (): void => {
  log('createWindow called');
  const { width, height } = getDefaultWindowSize();
  const isMac = process.platform === 'darwin';
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height,
    width,
    minWidth: 800,
    minHeight: 640,
    ...(isMac
      ? {
          titleBarStyle: 'hiddenInset' as const,
          trafficLightPosition: { x: 12, y: 12 },
        }
      : {}),
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      webviewTag: true,
    },
  });

  log('Window created. Loading loading screen...');
  mainWindow.loadURL(LOADING_WINDOW_WEBPACK_ENTRY);

  const initialServerUrl = process.env.TEATIME_SERVER_URL ?? DEFAULT_SERVER_URL;
  const initialWebUrl = process.env.TEATIME_WEB_URL ?? DEFAULT_WEB_URL;

  const startServices = app.isPackaged
    ? async () => {
        await startProductionServices();
        return { serverUrl: initialServerUrl, webUrl: initialWebUrl };
      }
    : () => ensureDevServices(initialServerUrl, initialWebUrl);

  startServices()
    .then(async ({ webUrl }) => {
      log('Services started. Waiting for web URL...');
      const targetUrl = app.isPackaged ? webUrl : `${webUrl}/`;
      const ok = await waitForUrlOk(targetUrl, {
        timeoutMs: 60_000,
        intervalMs: 300,
      });
      if (ok) {
          log(`Web URL ${targetUrl} is ok. Loading...`);
          return mainWindow.loadURL(targetUrl);
      }
      log('Web URL check failed. Reloading main entry as fallback (or staying on loading).');
      // If failed, maybe we should show an error page? For now fallback.
      return mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
    })
    .catch((err) => {
        log(`startServices failed: ${err}`);
        mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
    });

  // Open the DevTools.
  if (!app.isPackaged) {
      mainWindow.webContents.openDevTools();
  }
};

// Single instance lock
const gotTheLock = app.requestSingleInstanceLock();

if (!gotTheLock) {
  log('Could not get single instance lock. Quitting.');
  app.quit();
} else {
  app.on('second-instance', () => {
    log('Second instance detected.');
    const mainWindow = BrowserWindow.getAllWindows()[0];
    if (mainWindow) {
      if (mainWindow.isMinimized()) mainWindow.restore();
      mainWindow.focus();
    }
  });

  app.on('ready', () => {
      log('App ready event.');
      createWindow();
  });

  app.on('window-all-closed', () => {
    log('All windows closed.');
    if (process.platform !== 'darwin') {
      app.quit();
    }
  });

  app.on('before-quit', () => {
    log('Before quit.');
    stopManaged(managedWeb);
    stopManaged(managedServer);
    productionWebServer?.close();
  });

  app.on('activate', () => {
    log('Activate event.');
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
}

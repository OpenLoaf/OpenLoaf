import { app, BrowserWindow, screen } from 'electron';
import { spawn, type ChildProcess } from 'node:child_process';
import fs from 'node:fs';
import path from 'node:path';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

const DEFAULT_SERVER_URL = 'http://127.0.0.1:3000';
const DEFAULT_WEB_URL = 'http://127.0.0.1:3001';

const sleep = (ms: number) =>
  new Promise<void>((resolve) => setTimeout(resolve, ms));

const canFetch = typeof fetch === 'function';

async function isUrlOk(url: string): Promise<boolean> {
  if (!canFetch) return false;
  try {
    const res = await fetch(url, { method: 'GET' });
    return res.ok;
  } catch {
    return false;
  }
}

async function waitForUrlOk(
  url: string,
  { timeoutMs, intervalMs }: { timeoutMs: number; intervalMs: number }
): Promise<boolean> {
  const start = Date.now();
  for (;;) {
    if (await isUrlOk(url)) return true;
    if (Date.now() - start > timeoutMs) return false;
    await sleep(intervalMs);
  }
}

function findRepoRoot(startDir: string): string | null {
  let current = startDir;
  for (let i = 0; i < 12; i++) {
    if (
      fs.existsSync(path.join(current, 'pnpm-workspace.yaml')) &&
      fs.existsSync(path.join(current, 'turbo.json'))
    ) {
      return current;
    }
    const parent = path.dirname(current);
    if (parent === current) break;
    current = parent;
  }
  return null;
}

function commandName(base: string): string {
  return process.platform === 'win32' ? `${base}.cmd` : base;
}

function spawnLogged(
  label: string,
  command: string,
  args: string[],
  opts: { cwd: string; env: NodeJS.ProcessEnv }
): ChildProcess {
  const child = spawn(command, args, {
    cwd: opts.cwd,
    env: opts.env,
    stdio: ['ignore', 'pipe', 'pipe'],
  });

  child.stdout?.on('data', (d) => process.stdout.write(`[${label}] ${d}`));
  child.stderr?.on('data', (d) => process.stderr.write(`[${label}] ${d}`));
  child.on('exit', (code, signal) => {
    process.stdout.write(
      `[${label}] exited (${code ?? 'null'}, ${signal ?? 'null'})\n`
    );
  });

  return child;
}

let managedServer: ChildProcess | null = null;
let managedWeb: ChildProcess | null = null;

async function ensureDevServices(serverUrl: string, webUrl: string) {
  if (app.isPackaged) return;

  const repoRoot = findRepoRoot(process.cwd());
  if (!repoRoot) return;

  let serverOk = await isUrlOk(`${serverUrl}/`);
  let webOk = await isUrlOk(`${webUrl}/`);
  if (!serverOk || !webOk) {
    await sleep(1500);
    serverOk = serverOk || (await isUrlOk(`${serverUrl}/`));
    webOk = webOk || (await isUrlOk(`${webUrl}/`));
  }
  if (serverOk && webOk) return;

  const pnpm = commandName('pnpm');
  const envBase = { ...process.env };

  if (!serverOk) {
    managedServer = spawnLogged(
      'server',
      pnpm,
      ['--filter', 'server', 'dev'],
      {
        cwd: repoRoot,
        env: {
          ...envBase,
          PORT: new URL(serverUrl).port || '3000',
          HOST: new URL(serverUrl).hostname || '127.0.0.1',
          NODE_ENV: 'development',
          CORS_ORIGIN: `${webUrl},${envBase.CORS_ORIGIN ?? ''}`,
        },
      }
    );

    await waitForUrlOk(`${serverUrl}/`, { timeoutMs: 30_000, intervalMs: 300 });
  }

  if (!webOk) {
    managedWeb = spawnLogged('web', pnpm, ['--filter', 'web', 'dev'], {
      cwd: repoRoot,
      env: {
        ...envBase,
        NODE_ENV: 'development',
        NEXT_PUBLIC_SERVER_URL: serverUrl,
        NEXT_PUBLIC_ELECTRON: '1',
      },
    });
  }
}

function stopManaged(child: ChildProcess | null) {
  if (!child) return;
  if (child.killed) return;
  try {
    child.kill('SIGTERM');
  } catch {
    // ignore
  }
}

function getDefaultWindowSize(): { width: number; height: number } {
  const MIN_WIDTH = 800;
  const MIN_HEIGHT = 640;
  const MAX_WIDTH = 2000;
  const ASPECT_W = 16;
  const ASPECT_H = 10;

  const display = screen.getDisplayNearestPoint(screen.getCursorScreenPoint());
  const workAreaWidth = display.workAreaSize.width;

  let width = Math.round(workAreaWidth * 0.8);
  width = Math.min(width, MAX_WIDTH);
  width = Math.max(width, MIN_WIDTH);

  let height = Math.round((width * ASPECT_H) / ASPECT_W);
  if (height < MIN_HEIGHT) {
    height = MIN_HEIGHT;
    width = Math.round((height * ASPECT_W) / ASPECT_H);
    width = Math.min(width, MAX_WIDTH);
    width = Math.max(width, MIN_WIDTH);
  }

  return { width, height };
}

const createWindow = (): void => {
  const { width, height } = getDefaultWindowSize();
  const isMac = process.platform === 'darwin';
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height,
    width,
    minWidth: 800,
    minHeight: 640,
    ...(isMac
      ? {
          titleBarStyle: 'hiddenInset' as const,
          trafficLightPosition: { x: 12, y: 12 },
        }
      : {}),
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      webviewTag: true,
    },
  });

  const serverUrl = process.env.TEATIME_SERVER_URL ?? DEFAULT_SERVER_URL;
  const webUrl = process.env.TEATIME_WEB_URL ?? DEFAULT_WEB_URL;

  // In dev, start the monorepo web/server if they're not already running.
  ensureDevServices(serverUrl, webUrl)
    .then(async () => {
      const ok = await waitForUrlOk(`${webUrl}/`, {
        timeoutMs: 60_000,
        intervalMs: 300,
      });
      if (ok) return mainWindow.loadURL(webUrl);
      return mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
    })
    .catch(() => mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY));

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('before-quit', () => {
  stopManaged(managedWeb);
  stopManaged(managedServer);
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

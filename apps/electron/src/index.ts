import { app, BrowserWindow, screen } from 'electron';
import { spawn, type ChildProcess } from 'node:child_process';
import fs from 'node:fs';
import path from 'node:path';
import http from 'node:http';

// Logging setup immediately to catch early errors
const logPath = path.join(app.getPath('userData'), 'startup.log');

function log(message: string) {
  try {
    const timestamp = new Date().toISOString();
    fs.appendFileSync(logPath, `[${timestamp}] ${message}\n`);
  } catch (e) {
    // console.error('Failed to write log', e);
  }
}

// Clear log on startup
try {
  fs.writeFileSync(logPath, `--- Startup ---\n`);
} catch {}

process.on('uncaughtException', (error) => {
  log(`UNCAUGHT EXCEPTION: ${error.stack || error.message}`);
  // Keep app running if possible or let it crash after logging
});

process.on('unhandledRejection', (reason) => {
  log(`UNHANDLED REJECTION: ${reason}`);
});

log(`App starting. UserData: ${app.getPath('userData')}`);
log(`Executable: ${process.execPath}`);
log(`Resources Path: ${process.resourcesPath}`);

// Enable Chrome DevTools Protocol (CDP)
app.commandLine.appendSwitch('remote-debugging-port', '9222');

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const LOADING_WINDOW_WEBPACK_ENTRY: string;
declare const LOADING_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

const DEFAULT_SERVER_URL = 'http://127.0.0.1:3000';
const DEFAULT_WEB_URL = 'http://127.0.0.1:3001';

const MIME_TYPES: Record<string, string> = {
  '.html': 'text/html',
  '.js': 'text/javascript',
  '.css': 'text/css',
  '.json': 'application/json',
  '.png': 'image/png',
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.gif': 'image/gif',
  '.svg': 'image/svg+xml',
  '.ico': 'image/x-icon',
  '.woff': 'font/woff',
  '.woff2': 'font/woff2',
  '.ttf': 'font/ttf',
  '.txt': 'text/plain',
  '.webmanifest': 'application/manifest+json',
};

const sleep = (ms: number) =>
  new Promise<void>((resolve) => setTimeout(resolve, ms));

const canFetch = typeof fetch === 'function';

async function isUrlOk(url: string): Promise<boolean> {
  if (!canFetch) return false;
  try {
    const res = await fetch(url, { method: 'GET' });
    return res.ok;
  } catch {
    return false;
  }
}

async function waitForUrlOk(
  url: string,
  { timeoutMs, intervalMs }: { timeoutMs: number; intervalMs: number }
): Promise<boolean> {
  const start = Date.now();
  for (;;) {
    if (await isUrlOk(url)) return true;
    if (Date.now() - start > timeoutMs) return false;
    await sleep(intervalMs);
  }
}

function findRepoRoot(startDir: string): string | null {
  let current = startDir;
  for (let i = 0; i < 12; i++) {
    if (
      fs.existsSync(path.join(current, 'pnpm-workspace.yaml')) &&
      fs.existsSync(path.join(current, 'turbo.json'))
    ) {
      return current;
    }
    const parent = path.dirname(current);
    if (parent === current) break;
    current = parent;
  }
  return null;
}

function commandName(base: string): string {
  return process.platform === 'win32' ? `${base}.cmd` : base;
}

function spawnLogged(
  label: string,
  command: string,
  args: string[],
  opts: { cwd: string; env: NodeJS.ProcessEnv }
): ChildProcess {
  const child = spawn(command, args, {
    cwd: opts.cwd,
    env: opts.env,
    stdio: ['ignore', 'pipe', 'pipe'],
  });

  child.stdout?.on('data', (d) => process.stdout.write(`[${label}] ${d}`));
  child.stderr?.on('data', (d) => process.stderr.write(`[${label}] ${d}`));
  child.on('exit', (code, signal) => {
    process.stdout.write(
      `[${label}] exited (${code ?? 'null'}, ${signal ?? 'null'})\n`
    );
  });

  return child;
}

let managedServer: ChildProcess | null = null;
let managedWeb: ChildProcess | null = null;
let productionWebServer: http.Server | null = null;

async function ensureDevServices(serverUrl: string, webUrl: string) {
  if (app.isPackaged) return;

  const repoRoot = findRepoRoot(process.cwd());
  if (!repoRoot) return;

  let serverOk = await isUrlOk(`${serverUrl}/`);
  let webOk = await isUrlOk(`${webUrl}/`);
  if (!serverOk || !webOk) {
    await sleep(1500);
    serverOk = serverOk || (await isUrlOk(`${serverUrl}/`));
    webOk = webOk || (await isUrlOk(`${webUrl}/`));
  }
  if (serverOk && webOk) return;

  const pnpm = commandName('pnpm');
  const envBase = { ...process.env };

  if (!serverOk) {
    managedServer = spawnLogged(
      'server',
      pnpm,
      ['--filter', 'server', 'dev'],
      {
        cwd: repoRoot,
        env: {
          ...envBase,
          PORT: new URL(serverUrl).port || '3000',
          HOST: new URL(serverUrl).hostname || '127.0.0.1',
          NODE_ENV: 'development',
          CORS_ORIGIN: `${webUrl},${envBase.CORS_ORIGIN ?? ''}`,
        },
      }
    );

    await waitForUrlOk(`${serverUrl}/`, { timeoutMs: 30_000, intervalMs: 300 });
  }

  if (!webOk) {
    managedWeb = spawnLogged('web', pnpm, ['--filter', 'web', 'dev'], {
      cwd: repoRoot,
      env: {
        ...envBase,
        NODE_ENV: 'development',
        NEXT_PUBLIC_SERVER_URL: serverUrl,
        NEXT_PUBLIC_ELECTRON: '1',
      },
    });
  }
}

function serveStatic(req: http.IncomingMessage, res: http.ServerResponse, root: string) {
  try {
    let url = req.url || '/';
    // Remove query string
    url = url.split('?')[0];
    
    // Safety check
    if (url.includes('..')) {
      res.statusCode = 403;
      res.end('Forbidden');
      return;
    }

    let filePath = path.join(root, url);
    
    // Handle directory -> index.html
    if (fs.existsSync(filePath) && fs.statSync(filePath).isDirectory()) {
      filePath = path.join(filePath, 'index.html');
    }

    // Fallback logic for SPA / Next.js export
    if (!fs.existsSync(filePath)) {
      // 1. Try appending .html (e.g. /about -> /about.html)
      if (fs.existsSync(filePath + '.html')) {
        filePath += '.html';
      } 
      // 2. Try 404.html
      else if (fs.existsSync(path.join(root, '404.html'))) {
        filePath = path.join(root, '404.html');
      } 
      // 3. 404
      else {
        res.statusCode = 404;
        res.end('Not Found');
        return;
      }
    }

    const ext = path.extname(filePath).toLowerCase();
    const mimeType = MIME_TYPES[ext] || 'application/octet-stream';

    res.setHeader('Content-Type', mimeType);
    
    const stream = fs.createReadStream(filePath);
    stream.pipe(res);
    stream.on('error', (err) => {
        log(`Stream error serving ${filePath}: ${err.message}`);
        if (!res.headersSent) {
            res.statusCode = 500;
            res.end('Internal Server Error');
        }
    });

  } catch (err) {
    log(`Error in serveStatic: ${err instanceof Error ? err.message : String(err)}`);
    if (!res.headersSent) {
        res.statusCode = 500;
        res.end('Internal Server Error');
    }
  }
}

async function startProductionServices() {
  if (!app.isPackaged) return;

  log('Starting production services...');

  const resourcesPath = process.resourcesPath;
  const userDataPath = app.getPath('userData');
  const dbPath = path.join(userDataPath, 'teatime.db');
  
  // 1. Start Server
  // Note: server.mjs is copied to Resources/server.mjs
  const serverPath = path.join(resourcesPath, 'server.mjs');
  log(`Looking for server at: ${serverPath}`);
  
  if (fs.existsSync(serverPath)) {
      try {
          managedServer = spawn(process.execPath, [serverPath], {
            env: {
                ...process.env,
                ELECTRON_RUN_AS_NODE: '1',
                PORT: '3000',
                DATABASE_URL: `file:${dbPath}`,
                NODE_ENV: 'production'
            },
            stdio: ['ignore', 'pipe', 'pipe']
          });

          managedServer.stdout?.on('data', (d) => log(`[Server Output] ${d}`));
          managedServer.stderr?.on('data', (d) => log(`[Server Error] ${d}`));
          managedServer.on('error', (err) => log(`[Server Spawn Error] ${err.message}`));
          managedServer.on('exit', (code, signal) => log(`[Server Exited] code=${code} signal=${signal}`));

          log('Server process spawned');
      } catch (err) {
          log(`Failed to spawn server: ${err instanceof Error ? err.message : String(err)}`);
      }
  } else {
      log(`[Error] Server binary not found at ${serverPath}`);
  }

  // 2. Start Web Server
  // Note: web/out is copied to Resources/out
  const webRoot = path.join(resourcesPath, 'out');
  log(`Looking for web root at: ${webRoot}`);
  
  if (fs.existsSync(webRoot)) {
      try {
          productionWebServer = http.createServer((req, res) => {
              serveStatic(req, res, webRoot);
          });
          
          await new Promise<void>((resolve, reject) => {
              productionWebServer?.listen(3001, () => {
                 log('Web server running at http://localhost:3001');
                 resolve();
              });
              productionWebServer?.on('error', reject);
          });
      } catch (err) {
          log(`Failed to start web server: ${err instanceof Error ? err.message : String(err)}`);
      }
  } else {
       log(`[Error] Web root not found at ${webRoot}`);
  }
}


function stopManaged(child: ChildProcess | null) {
  if (!child) return;
  if (child.killed) return;
  try {
    child.kill('SIGTERM');
  } catch {
    // ignore
  }
}

function getDefaultWindowSize(): { width: number; height: number } {
  const MIN_WIDTH = 800;
  const MIN_HEIGHT = 640;
  const MAX_WIDTH = 2000;
  const ASPECT_W = 16;
  const ASPECT_H = 10;

  const display = screen.getDisplayNearestPoint(screen.getCursorScreenPoint());
  const workAreaWidth = display.workAreaSize.width;

  let width = Math.round(workAreaWidth * 0.8);
  width = Math.min(width, MAX_WIDTH);
  width = Math.max(width, MIN_WIDTH);

  let height = Math.round((width * ASPECT_H) / ASPECT_W);
  if (height < MIN_HEIGHT) {
    height = MIN_HEIGHT;
    width = Math.round((height * ASPECT_W) / ASPECT_H);
    width = Math.min(width, MAX_WIDTH);
    width = Math.max(width, MIN_WIDTH);
  }

  return { width, height };
}

const createWindow = (): void => {
  log('createWindow called');
  const { width, height } = getDefaultWindowSize();
  const isMac = process.platform === 'darwin';
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height,
    width,
    minWidth: 800,
    minHeight: 640,
    ...(isMac
      ? {
          titleBarStyle: 'hiddenInset' as const,
          trafficLightPosition: { x: 12, y: 12 },
        }
      : {}),
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      webviewTag: true,
    },
  });

  log('Window created. Loading loading screen...');
  mainWindow.loadURL(LOADING_WINDOW_WEBPACK_ENTRY);

  const serverUrl = process.env.TEATIME_SERVER_URL ?? DEFAULT_SERVER_URL;
  const webUrl = process.env.TEATIME_WEB_URL ?? DEFAULT_WEB_URL;

  const startServices = app.isPackaged 
    ? startProductionServices 
    : () => ensureDevServices(serverUrl, webUrl);

  startServices()
    .then(async () => {
      log('Services started. Waiting for web URL...');
      const targetUrl = app.isPackaged ? webUrl : `${webUrl}/`;
      const ok = await waitForUrlOk(targetUrl, {
        timeoutMs: 60_000,
        intervalMs: 300,
      });
      if (ok) {
          log(`Web URL ${targetUrl} is ok. Loading...`);
          return mainWindow.loadURL(targetUrl);
      }
      log('Web URL check failed. Reloading main entry as fallback (or staying on loading).');
      // If failed, maybe we should show an error page? For now fallback.
      return mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
    })
    .catch((err) => {
        log(`startServices failed: ${err}`);
        mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
    });

  // Open the DevTools.
  if (!app.isPackaged) {
      mainWindow.webContents.openDevTools();
  }
};

// Single instance lock
const gotTheLock = app.requestSingleInstanceLock();

if (!gotTheLock) {
  log('Could not get single instance lock. Quitting.');
  app.quit();
} else {
  app.on('second-instance', () => {
    log('Second instance detected.');
    const mainWindow = BrowserWindow.getAllWindows()[0];
    if (mainWindow) {
      if (mainWindow.isMinimized()) mainWindow.restore();
      mainWindow.focus();
    }
  });

  app.on('ready', () => {
      log('App ready event.');
      createWindow();
  });

  app.on('window-all-closed', () => {
    log('All windows closed.');
    if (process.platform !== 'darwin') {
      app.quit();
    }
  });

  app.on('before-quit', () => {
    log('Before quit.');
    stopManaged(managedWeb);
    stopManaged(managedServer);
    productionWebServer?.close();
  });

  app.on('activate', () => {
    log('Activate event.');
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
}

